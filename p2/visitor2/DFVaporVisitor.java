//
// Generated by JTB 1.3.2
//

package visitor2;
import visitor.Visitor;
import syntaxtree.*;
import struct.*;
import toolbox.*;
import java.util.*;
import java.lang.*; // StringBuffer

/**
* Provides default methods which visit each node in the tree in depth-first
* order.  Your visitors may extend this class.
*/
public class DFVaporVisitor implements Visitor
{
    Map<String,Map<String,Struct>> symbol_table; // from DFStackVisitor2
    StringBuffer str_buf;    // write the intermediate code generation here
    int var_cnt = 0;         // counter for distinct variables, increment every time variable created
    int lbl_cnt = 0;         // counter for distinct goto labels, increment every time label created
    int indent_cnt = 0;      // count the indentation depth, increment on enter blocks, decrement on exit blocks
    String var_name = "tmp"; // tmp variable name string
    String lbl_name = "lbl"; // label name string
    String indent = "  ";    // 2 spaces for the indents
    Stack<String> var_stk;   // stack to get last used variable
    Stack<Map<String,String>> name_map_stk; // associate variables with their current tmps
    String current_class;
    String current_function;
    String cur_name; // track current identifier
    String old_name; // track the previous identifier
    boolean if_param_flag = false; // track if inside the expression argument to an if statement
    String  if_param_arg = "";  // used for branch/loops, put the name of the specific temp that goes in the argument spot: if(HERE){...} else{...}
    Vector<String> fcall_params;

    public DFVaporVisitor(Map<String, Map<String,Struct>> m) // constructor takes in the symbol table from the DFStackVisitor2
    {
        symbol_table = m;
        str_buf = new StringBuffer();
        var_stk = new Stack<String>();
        name_map_stk = new Stack<Map<String,String>>();
        fcall_params = new Vector<String>();
    }

    // helpers
    void MapDump() // print the top map on stack
    {
        name_map_stk.peek().forEach( (k,v) -> System.out.println("( "+ k + " : " + v + " )") ); // dump map
        System.out.println("");
    }

    void ErrorPrinter(Exception e)
    {
        System.out.println("AN ERROR HAPPENED...");
        e.printStackTrace();
        System.out.println("\nTop Map Dump");
        MapDump();
        System.out.println("\nString Buffer Dump");
        System.out.println(str_buf.toString());
    }

    /* ---------- VISITOR STUFFS BELOW ---------- */

    //
    // Auto class visitors--probably don't need to be overridden.
    //
    public void visit(NodeList n) {
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
         e.nextElement().accept(this);
    }

    public void visit(NodeListOptional n) {
      if ( n.present() )
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
            e.nextElement().accept(this);
    }

    public void visit(NodeOptional n) {
      if ( n.present() )
         n.node.accept(this);
    }

    public void visit(NodeSequence n) {
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
         e.nextElement().accept(this);
    }

    public void visit(NodeToken n) { }

    //
    // User-generated visitor methods below
    //

    /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
    public void visit(Goal n)
    {
        try
        {
                // here do the vtables for the other classes before the main class
                StringBuffer temp = tools.create_vtables(symbol_table);
                str_buf.append(temp.toString());

            n.f0.accept(this); // goto main there do the main function
            n.f1.accept(this); // goto the classes and do their records
            n.f2.accept(this);

                System.out.println(str_buf.toString()); // print out the complete Vapor IR code
        }
        catch(Exception e)
        {
            ErrorPrinter(e); // to print the crash information
        }
    }

    /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( Statement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
    public void visit(MainClass n) // special case for the main method, dont need to do a vtable or a record. just output function only
    {
        n.f0.accept(this);
        n.f1.accept(this);
            current_class = cur_name;
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);
            current_function = "main";
            str_buf.append("func Main()\n"); // declare the main function
            indent_cnt++;   // increase indent on enter main

            Map<String,String> main_vars = new HashMap<String,String>(); // to associate the java name with the cur tmp variable in vapor
            name_map_stk.push(main_vars);

        n.f7.accept(this);
        n.f8.accept(this);
        n.f9.accept(this);
        n.f10.accept(this);
        n.f11.accept(this);
        n.f12.accept(this);
        n.f13.accept(this);
        n.f14.accept(this);
        n.f15.accept(this);
        n.f16.accept(this);
        n.f17.accept(this);

            str_buf.append(indent + "ret" + "\n" ); // void function return
            indent_cnt--;   // decrease indent on leave main

            name_map_stk.pop();
            current_function = "";
            current_class = "";
    }

    /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
    public void visit(TypeDeclaration n)
    {
        n.f0.accept(this);
    }

    /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
    public void visit(ClassDeclaration n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
        current_class = cur_name;
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        current_class = "";
    }

    /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
    public void visit(ClassExtendsDeclaration n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
        current_class = cur_name;
        n.f2.accept(this);
        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);
        n.f7.accept(this);
        current_class = "";
    }

    /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
    public void visit(VarDeclaration n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
    public void visit(MethodDeclaration n) // Broken, cant return literals???? <---------- FIXME
    {
            name_map_stk.push(new HashMap<String, String>());

        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);

            current_function = cur_name;
            Struct current_method = symbol_table.get(current_class).get(current_function);
            str_buf.append("\nfunc " + current_class + "." + current_function + "(this");

            String tmp_str = "";

            for(Struct i: current_method.getParams()) {
              str_buf.append(" " + i.getName());
              String new_temp = var_name + var_cnt;
              var_cnt++;
              var_stk.push(new_temp);
              name_map_stk.peek().put(i.getName(), new_temp);

              String tsts = "  " + new_temp + " = " + i.getName() + "\n";
              tmp_str += tsts;
            }

            str_buf.append(")" + "\n");
            indent_cnt++;

            // MapDump();

            // init the params here???
            str_buf.append(tmp_str);

        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);
        n.f6.accept(this);
        n.f7.accept(this);
        n.f8.accept(this);
        n.f10.accept(this);

            // System.out.println("in fun def: " + cur_name);    // name of return item is is a variable
            // MapDump();

            String tmp1 = "";
            for(String i: name_map_stk.peek().keySet()) {  // probably not going to work for literals
                if(i == cur_name) {
                    tmp1 = name_map_stk.peek().get(i);
                    // System.out.println("func ret#1: " + tmp1);
                }
            }

            if(tmp1 == "") // if didnt find the name then probably is return a literal or expression
            {
                tmp1 = var_stk.pop();
                // System.out.println("func ret#2: " + tmp1); // last thing on stack probably is what should be returned
            }

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            String answer = printdent + "ret " + tmp1 + "\n";
            str_buf.append(answer);

        n.f11.accept(this);

            indent_cnt--;

        n.f12.accept(this);

            // MapDump();

            current_function = "";
            name_map_stk.pop();
    }

    /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
    public void visit(FormalParameterList n)  // <----  probably need to collect the params for function declarations
    {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
    public void visit(FormalParameter n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
    public void visit(FormalParameterRest n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
    }

    /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
    public void visit(Type n)
    {
        n.f0.accept(this);
    }

    /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
    public void visit(ArrayType n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
    * f0 -> "boolean"
    */
    public void visit(BooleanType n)
    {
        n.f0.accept(this);
    }

    /**
    * f0 -> "int"
    */
    public void visit(IntegerType n)
    {
        n.f0.accept(this);
    }

    /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
    public void visit(Statement n)
    {
        n.f0.accept(this);
    }

    /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
    public void visit(Block n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

    /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
    public void visit(AssignmentStatement n)
    {
            if(cur_name != "")
            {
                old_name = cur_name; // get old name
            }

        n.f0.accept(this);

            String a_name = cur_name;

            // System.out.println("in assign: " + a_name);
            // MapDump();

        n.f1.accept(this);
        n.f2.accept(this);

            String name;
            String tmpexp = "";

            if(!var_stk.empty())
            {
                tmpexp = var_stk.pop();
                // System.out.println("in assign -- cname1: " + tmpexp);
            }
            else // idk what should happen
            {
                // System.out.println("in assign -- cname2: " + cur_name); // class name
            }

            String tmpid = var_name + Integer.toString(var_cnt);
            var_cnt++;

            /*if( old_name != ""  && cur_name == "" )
            {
                System.out.println("set to old name");
                name = old_name;
            }
            else
            {
                System.out.println("set to cur name");
                name = cur_name;
            }*/

            name = a_name; // idk wtf

            if(name_map_stk.peek().get(name) != null)
            {
                // System.out.println("ASS#1");
                // System.out.println("C: " + cur_name + " O: " + old_name + " " + tmpid);
                // System.out.println(var_stk.peek());
                // System.out.println(a_name);
                // MapDump();
                // // name_map_stk.peek().replace(a_name,tmpid); // not this probably ??
                // MapDump();
                tmpid = name_map_stk.peek().get(a_name);
            }
            else
            {
                // System.out.println("ASS#2");
                // System.out.println("C: " + cur_name + " O: " + old_name + " " + tmpid);
                // MapDump();
                name_map_stk.peek().put(name,tmpid);
                // MapDump();
            }

            var_stk.push(tmpid);
            
            System.out.println();

            String assign = tmpid + " = " + tmpexp + "\n";

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append(printdent + assign);

            cur_name = ""; // clear name

        n.f3.accept(this);
    }

    /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
    public void visit(ArrayAssignmentStatement n)   // NOT DONE <----------- FIXME
    {
        n.f0.accept(this);

            String arr = var_stk.pop();

        n.f1.accept(this);
        n.f2.accept(this);

            String i = var_stk.pop();

        n.f3.accept(this);
        n.f4.accept(this);
        n.f5.accept(this);

            String expr = var_stk.pop();

        n.f6.accept(this);

            String printdent = "";
            for(int j = 0; j < indent_cnt; j++)
            {
                printdent += indent;
            }

            // MapDump();

            String tmp1 = var_name + var_cnt;
            var_cnt++;
            var_stk.push(tmp1);
            String append1 = printdent + tmp1 + " = [" + arr + "- 4]\n";
            String tmp2 = var_name + var_cnt;
            var_cnt++;
            var_stk.push(tmp2);
            String append2 = printdent + tmp2  + " = LtS(" + i + " " + tmp1 + ")\n";
            String label1 = lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;
            String label2 = lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            String append3 = printdent + "if " + tmp2 + " goto :" + label1 + "\n";
            String append4 =  printdent + "  Error(\"array index out of bounds\")\n";
            String append5 = printdent + label1 + ": \n";
            String append55 = printdent + tmp2 + " = LtS( -1" + " " + i + ")\n";
            String append6 = printdent + "  if " + tmp2 + " goto :" + label2 + "\n";
            String append7 = printdent + "  Error(\"array index out of bounds\")\n";
            String tmp3 = var_name + var_cnt;
            var_cnt++;
            var_stk.push(tmp3);
            String append8 = printdent + label2 + ": \n";
            String append88 = printdent + tmp3 + " = MulS(" + i + " 4)\n";
            String tmp4 = var_name + var_cnt;
            var_cnt++;
            var_stk.push(tmp4);
            String append9 = printdent +  tmp4 + " = Add(" + arr + " " + tmp3 + ") \n";
            String append10 = printdent +  "[" + tmp4 + "] = " + expr + "\n";

            str_buf.append(append1);
            str_buf.append(append2);
            str_buf.append(append3);
            str_buf.append(append4);
            str_buf.append(append5);
            str_buf.append(append55);
            str_buf.append(append6);
            str_buf.append(append7);
            str_buf.append(append8);
            str_buf.append(append88);
            str_buf.append(append9);
            str_buf.append(append10);



    }

    /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
    public void visit(IfStatement n)
    {
            String label_else = "else_start_" + lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            String label_end = "if_end_" + lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

        n.f0.accept(this);
        n.f1.accept(this);

            // str_buf.append( printdent + "code for the boolean expression\n");

            if_param_flag = true;
        n.f2.accept(this); // code for the bool_expr
            if_param_flag = false;

            String bool_expr = if_param_arg;

            // IF0 (valOf(bool_expr) == false) THEN GOTO B
            str_buf.append( printdent + "if0 " + bool_expr + " goto :" + label_else + "\n");

        n.f3.accept(this);

            // A <---- valOf(bool_expr) == true
            // str_buf.append( printdent + "code for statement 1 below\n");

            indent_cnt++;
        n.f4.accept(this); // code for statement #1
            indent_cnt--;

            // GOTO END
            str_buf.append( printdent + "goto :" + label_end + "\n");

        n.f5.accept(this);

            // B <---- valOf(bool_expr) == false
            str_buf.append( printdent + label_else + ":\n");
            // str_buf.append( printdent + "code for statement 2 below\n");

            indent_cnt++;
        n.f6.accept(this); // code for statement #2
            indent_cnt--;

            // END
            str_buf.append(printdent + label_end + ":\n");
    }

    /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
    public void visit(WhileStatement n)
    {

            String label_begin = "loop_start_" + lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            String label_end = "loop_end_" + lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            // BEGIN
            str_buf.append(printdent + label_begin + ":\n");

        n.f0.accept(this);
        n.f1.accept(this);

            if_param_flag = true;
        n.f2.accept(this);  // code for bool expr
            if_param_flag = false;

            String bool_expr = if_param_arg;

            // IF0 (valOf(bool_expr) == false) THEN GOTO B
            str_buf.append( printdent + "if0 " + bool_expr + " goto :" + label_end + "\n");

        n.f3.accept(this);

            indent_cnt++;
        n.f4.accept(this);
            indent_cnt--;

            str_buf.append("  " + printdent + "goto :" + label_begin + "\n");

            // END
            str_buf.append(printdent + label_end + ":\n");
    }

    /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
    public void visit(PrintStatement n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);

            String tmp = "";
            String name = cur_name;

            // if( name_map_stk.peek().get(name) == null )
            // {
                // // grab the name of the last tmp variable
                // tmp = var_stk.pop();
            // }
            // else
            // {
            //     tmp = name_map_stk.peek().get(name);
            // }

            // var_stk could be empty... DANGER CAUSES CRASH IF EMPTY
            if(!var_stk.empty()) // Broken, idk what to do here when needs return value from a function call  <------ FIXME
            {
                tmp = var_stk.pop();
            }

        n.f3.accept(this);
        n.f4.accept(this);

            // write out the print statement with indents
            String printints = "PrintIntS(" + tmp + ")\n";

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append( printdent + printints );

            cur_name = "";
    }

    /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
    public void visit(Expression n)
    {
        n.f0.accept(this);
    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
    public void visit(AndExpression n)
    {
        n.f0.accept(this);

            // pop
            String v1 = var_stk.pop();

        n.f1.accept(this); // "&&"
        n.f2.accept(this);

            // pop
            String v2 = var_stk.pop();

            // here do the double if same for and/not
            // two if0 instructions that check if each of the operands is zero,
            // assign zero to the result and goto the end label.
            // Before the end label, one is assigned to the result.

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            String tv1 = var_name + Integer.toString(var_cnt); //v1
            var_cnt++;

            String tv2 = var_name + Integer.toString(var_cnt); // 0
            var_cnt++;

            String tv3 = var_name + Integer.toString(var_cnt); // v1 < 0
            var_cnt++;

            String tv4 = var_name + Integer.toString(var_cnt); // v2
            var_cnt++;

            String tv5 = var_name + Integer.toString(var_cnt); // v2 < 0
            var_cnt++;

            String tv6 = var_name + Integer.toString(var_cnt); // sum of both Eq statements
            var_cnt++;

            String tv7 = var_name + Integer.toString(var_cnt); // result value of the and, set to either 0 or 1
            var_cnt++;

            String lb1 = lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            String lb2 = lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            // str_buf.append(printdent + "in && Expression !!!!!!!!!!!"+ "\n");
            // str_buf.append(printdent + "v1: " + v1+ "\n");
            // str_buf.append(printdent + "v2: " + v2+ "\n");

            String x = tv1 + " = " + v1 + "\n";
            str_buf.append(printdent + x); // set tmp to var1

            String y = tv2 + " = " + "0" + "\n";
            str_buf.append(printdent + y); // set tmp to 0

            String z = tv3 + " = " +  "Eq(" +  tv1 + " " + tv2 + ")\n"; // if is 1 then v1 = true
            str_buf.append(printdent + z); // is v1 = 0 ?

            String a = tv4 + " = " + v2 + "\n";
            str_buf.append(printdent + a); // set tmp to var2

            String b = tv5 + " = " + "Eq(" +  tv4 + " " + tv2 + ")\n"; // if is 1 then v2 = true
            str_buf.append(printdent + b); // is v2 = 0 ?

            // check if the sum of both Eq is 0
            String c = tv6 + " = " + "Add(" +  tv3 + " " + tv5 + ")\n"; // sum the Eqs
            str_buf.append(printdent + c); //

            str_buf.append(  printdent + "if0 " + tv6 + " goto :" + lb1 + "\n" ); // if the sum was 0 then goto end
            String d = tv7 + " = 0\n";
            str_buf.append("  " + printdent + d); // set tmp to 0
            str_buf.append("  " + printdent + "goto :" + lb2 + "\n" ); // set tmp to 0
            // ELSE
            str_buf.append( printdent + lb1 + ":\n"); // else label - both were true
            // else set result to 1
            String e = tv7 + " = 1\n";
            str_buf.append("  " + printdent + e); // set tmp to 1

            // END
            str_buf.append(printdent + lb2 + ":\n"); // else label - both were true

            if(if_param_flag == true)
            {
                if_param_arg = tv7;
            }

            // str_buf.append(printdent + "End of the && expression !!!!!!!!!!!!!!!\n");
    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
    public void visit(CompareExpression n)
    {
        // get tmp
        String val2;
        String val1;
        String name;

        n.f0.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val1 = var_stk.pop();
            }
            else
            {
                val1 = name_map_stk.peek().get(name);
            }

            cur_name = "";

        n.f1.accept(this);

        n.f2.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val2 = var_stk.pop();
            }
            else
            {
                val2 = name_map_stk.peek().get(name);
            }

            String tmpres = var_name + Integer.toString(var_cnt); // create new tmp var for result of operation
            var_cnt++; // increment variable number

            var_stk.push(tmpres); // push tmp on stack

            String result = tmpres + " = LtS(" + val1 + " " + val2 + ")\n";

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append(printdent + result);

            cur_name = "";

            if(if_param_flag == true) // maybe a special case for when less than
            {
                if_param_arg = tmpres;
            }
    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
    public void visit(PlusExpression n)
    {
        // get tmp
        String val2;
        String val1;
        String name;

        n.f0.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val1 = var_stk.pop();
            }
            else
            {
                val1 = name_map_stk.peek().get(name);
            }

            cur_name = "";

        n.f1.accept(this);

        n.f2.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val2 = var_stk.pop();
            }
            else
            {
                val2 = name_map_stk.peek().get(name);
            }

            String tmpres = var_name + Integer.toString(var_cnt); // create new tmp var for result of operation
            var_cnt++; // increment variable number

            var_stk.push(tmpres); // push tmp on stack

            String result = tmpres + " = Add(" + val1 + " " + val2 + ")\n";

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append(printdent + result);

            cur_name = "";
    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
    public void visit(MinusExpression n)
    {
        // get tmp
        String val2;
        String val1;
        String name;

        n.f0.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val1 = var_stk.pop();
            }
            else
            {
                val1 = name_map_stk.peek().get(name);
            }

            cur_name = "";

        n.f1.accept(this);

        n.f2.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val2 = var_stk.pop();
            }
            else
            {
                val2 = name_map_stk.peek().get(name);
            }

            String tmpres = var_name + Integer.toString(var_cnt); // create new tmp var for result of operation
            var_cnt++; // increment variable number

            var_stk.push(tmpres); // push tmp on stack

            String result = tmpres + " = Sub(" + val1 + " " + val2 + ")\n";

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append(printdent + result);

            cur_name = "";
    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
    public void visit(TimesExpression n)
    {
        // get tmp
        String val2;
        String val1;
        String name;

        n.f0.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val1 = var_stk.pop();
            }
            else
            {
                val1 = name_map_stk.peek().get(name);
            }

            cur_name = "";

        n.f1.accept(this);

        n.f2.accept(this);

            name = cur_name;
            if( name_map_stk.peek().get(name) == null )
            {
                // grab the name of the last tmp variable
                val2 = var_stk.pop();
            }
            else
            {
                val2 = name_map_stk.peek().get(name);
            }

            String tmpres = var_name + Integer.toString(var_cnt); // create new tmp var for result of operation
            var_cnt++; // increment variable number

            var_stk.push(tmpres); // push tmp on stack

            String result = tmpres + " = MulS(" + val1 + " " + val2 + ")\n";

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append(printdent + result);

            cur_name = "";
    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
    public void visit(ArrayLookup n)   // NOT DONE <----------- FIXME
    {
        n.f0.accept(this);

            String arr = var_stk.pop();

        n.f1.accept(this);
        n.f2.accept(this);

            String i = var_stk.pop();

        n.f3.accept(this);

        String printdent = "";
        for(int j = 0; j < indent_cnt; j++)
        {
            printdent += indent;
        }

        // MapDump();

        String tmp1 = var_name + var_cnt;
        var_cnt++;
        var_stk.push(tmp1);
        String append1 = printdent + tmp1 + " = [" + arr + "- 4]\n";
        String tmp2 = var_name + var_cnt;
        var_cnt++;
        var_stk.push(tmp2);
        String append2 = printdent + tmp2  + " = LtS(" + i + " " + tmp1 + ")\n";
        String label1 = lbl_name + Integer.toString(lbl_cnt);
        lbl_cnt++;
        String label2 = lbl_name + Integer.toString(lbl_cnt);
        lbl_cnt++;

        String append3 = printdent + "if " + tmp2 + " goto :" + label1 + "\n";
        String append4 =  printdent + "  Error(\"array index out of bounds\")\n";
        String append5 = printdent + label1 + ": \n";
        String append55 = printdent + tmp2 + " = LtS(-1" + " " + i + ")\n";
        String append6 = printdent + "if " + tmp2 + " goto :" + label2 + "\n";
        String append7 = printdent + "  Error(\"array index out of bounds\")\n";
        String tmp3 = var_name + var_cnt;
        var_cnt++;
        var_stk.push(tmp3);
        String append8 = printdent + label2 + ": \n";
        String append88 = printdent + tmp3 + " = MulS(" + i + " 4)\n";
        String tmp4 = var_name + var_cnt;
        var_cnt++;
        var_stk.push(tmp4);
        String append9 = printdent + tmp4 + " = Add(" + arr + " " + tmp3 + ") \n";
        String tmp5 = var_name + var_cnt;
        var_cnt++;
        var_stk.push(tmp5);
        String append10 = printdent + tmp5 + " = [" + tmp4 + "]" + "\n";

        str_buf.append(append1);
        str_buf.append(append2);
        str_buf.append(append3);
        str_buf.append(append4);
        str_buf.append(append5);
        str_buf.append(append55);
        str_buf.append(append6);
        str_buf.append(append7);
        str_buf.append(append8);
        str_buf.append(append88);
        str_buf.append(append9);
        str_buf.append(append10);


    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
    public void visit(ArrayLength n)  // NOT DONE <----------- FIXME
    {
        n.f0.accept(this);
            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            String tmp1 = var_stk.pop();
            String tmp2 = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmp2);

            String append1 = printdent + tmp2 + " = [" + tmp1 + "- 4]\n";
            str_buf.append(append1);



        n.f1.accept(this);
        n.f2.accept(this);

    }

    /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
    public void visit(MessageSend n)   // NOT DONE <----------- FIXME -- Function calls
    {

            // var_stk is probably empty at this point

        n.f0.accept(this);

            // System.out.println("name_c: " + cur_name); // actual class name
            // System.out.println("class_c: " + current_class); // name of class if is a THIS
            // System.out.println(var_stk.peek());  // probably the tmp var name of the caller class

            String name_c = cur_name;   // class name
            String tmp_obj = "";        // actual anme of tmp variable that is the object

            if(!var_stk.empty())
            {
                tmp_obj = var_stk.pop(); // get the tmp object so can use the vtable
            }
            else
            {
                tmp_obj = "this"; // looks like the "this" isnt on the stack
            }

            // System.out.println(tmp_obj);
            // MapDump();

            // weird bs here
            // if found a value in the name map then put value back on var_stk and set tmp_obj to "this"
            for(String nms : name_map_stk.peek().values())
            {
                if(nms == tmp_obj)
                {
                    // System.out.println("ooof");
                    var_stk.push(tmp_obj);
                    tmp_obj = "this";
                }
            }

            // System.out.println(tmp_obj);
            // MapDump();

        n.f1.accept(this);
        n.f2.accept(this);

            // System.out.println("name_f: " + cur_name); // actual function name
            // System.out.println(var_stk.peek());

            String name_f = cur_name;   // function name

        n.f3.accept(this);
        n.f4.accept(this);

            // System.out.println(var_stk.peek()); // probably have do do something special to collect params

        n.f5.accept(this);

            // System.out.println( name_c + " " + name_f + " " + tmp_obj );

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            String tmp_val = var_name + Integer.toString(var_cnt);
            var_cnt++;

            String tmp_ret = var_name + Integer.toString(var_cnt);
            var_cnt++;

            // need to get the offset into the vtable of the function
            // have to lookup function inside of the class struct and then do the index * 4

            String lookup_name = "";
            if(name_c == "")
            {
                lookup_name = current_class;    // this means need to check current class
            }
            else
            {
                lookup_name = name_c;
            }

            // System.out.println("lkup: " + lookup_name);

            Struct struct_c = symbol_table.get("Global").get(lookup_name);

            if(struct_c == null) // looked up an id with name_c, but since isnt a class will be null, need to relookup up by class
            {
                // System.out.println("NULL STRUCT WAS RETURNED");
                lookup_name = current_class;    // this means need to check current class
                struct_c = symbol_table.get("Global").get(lookup_name);
            }

            Vector<Pair> vs2 = toolbox.tools.vtable_correct(struct_c, symbol_table); // probably fix this with different order for methods <---- FIXME
            int position = 0;

            for(int i = 0; i < vs2.size(); i++)
            {
                if(vs2.get(i).getValue().getName() == name_f)
                {
                    position = i;
                }
            }

            int offs = 0 + (4*position);
            String offset_f = Integer.toString(offs);

            // need to get the params for the function
            String params_f = "";
            for(String pp : fcall_params)
            {
                // get the params and separate with spaces
                params_f += " ";
                params_f += pp;
                params_f += " ";
            }

            fcall_params = new Vector<String>(); // reset and clear old params for next time

            String a = printdent + tmp_val + " = [" + tmp_obj + "]\n";
            String b = printdent + tmp_val + " = [" + tmp_val + "+" + offset_f + "]\n";
            String c = printdent + tmp_ret + " = call " + tmp_val + "(" + tmp_obj + params_f + ")\n";

            str_buf.append(a+b+c);

            var_stk.push(tmp_ret);
    }

    /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
    public void visit(ExpressionList n) // probably need to do stuff in the expression rest also
    {
        n.f0.accept(this);

            if(!var_stk.empty())
            {
                // System.out.println(var_stk.peek());
                fcall_params.add(var_stk.pop());
            }

        n.f1.accept(this);
    }

    /**
    * f0 -> ","
    * f1 -> Expression()
    */
    public void visit(ExpressionRest n)
    {
        n.f0.accept(this);
        n.f1.accept(this);

            if(!var_stk.empty())
            {
                // System.out.println(var_stk.peek());
                fcall_params.add(var_stk.pop());
            }

    }

    /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
    public void visit(PrimaryExpression n)
    {
        n.f0.accept(this);
    }

    /**
    * f0 -> <INTEGER_LITERAL>
    */
    public void visit(IntegerLiteral n)
    {
        n.f0.accept(this);

            String tmpid = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmpid); // put new tmp int var onto the stack

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append( printdent + tmpid + " = " + n.f0.toString() + "\n");
    }

    /**
    * f0 -> "true"
    */
    public void visit(TrueLiteral n) // true == 1
    {
        n.f0.accept(this);

            String tmpid = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmpid); // put new tmp int var onto the stack

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append( printdent + tmpid + " = 1\n");

            if(if_param_flag == true) // maybe a special case for when single true is in the if expression
            {
                if_param_arg = tmpid;
            }
    }

    /**
    * f0 -> "false"
    */
    public void visit(FalseLiteral n) // false == 0
    {
        n.f0.accept(this);

            String tmpid = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmpid); // put new tmp int var onto the stack

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append( printdent + tmpid + " = 0\n");

            if(if_param_flag == true) // maybe a special case for when single false is in the if expression
            {
                if_param_arg = tmpid;
            }
    }

    /**
    * f0 -> <IDENTIFIER>
    */
    public void visit(Identifier n)
    {
        n.f0.accept(this);

            cur_name = n.f0.toString();

            // System.out.println(cur_name);

            if(symbol_table.get(cur_name) != null ) // if exists in map then is a class/function
            {
                return;
            }

            if(name_map_stk.empty() || name_map_stk.peek().get(cur_name) == null)  // dont create random null vars?
            {
                return;
            }

            // System.out.println(cur_name);
            // MapDump();

            String tmpid = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmpid); // put new tmp int var onto the stack

            // System.out.println("in id: " + tmpid);

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            str_buf.append( printdent + tmpid + " = " + name_map_stk.peek().get(cur_name) + "\n");

            if(if_param_flag == true) // maybe a special case for when single id is in the if expression
            {
                if_param_arg = name_map_stk.peek().get(cur_name); // might break if empty stack?
            }
    }

    /**
    * f0 -> "this"
    */
    public void visit(ThisExpression n)   // NOT DONE <----------- FIXME  // maybe need to do class fetch, not sure...
    {
        n.f0.accept(this);

            // probably should push the word this on stack, or maybe get the class and do that ???
            var_stk.push("this");
    }

    /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
    public void visit(ArrayAllocationExpression n)   // NOT DONE <----------- FIXME // DO MAKE ARRAY HERE
    {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
        n.f3.accept(this);

            // probably pop from stack to get the tmp which hold value of the expression?
            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }
            String expr_temp = var_stk.pop();
            String tmp1 = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmp1);
            String append1 = printdent + tmp1 + " = MulS(" + expr_temp + " 4)\n";
            String tmp2 = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmp2);
            // HeapAllocZ(alloc);
            String append2 = printdent + tmp2 + " = Add(" + tmp1 + " 4)\n";
            String tmp3 = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmp3);
            String append3 = printdent + tmp3 + " = HeapAllocZ(" + tmp2 + ")\n";
            String tmp4 = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmp4);
            String append5 = printdent + tmp4 + " = Add(" + tmp3 + " 4)\n";
            String append4 = printdent + "[" + tmp4 + " - 4] = " + expr_temp + "\n";

            str_buf.append(append1);
            str_buf.append(append2);
            str_buf.append(append3);
            str_buf.append(append5);
            str_buf.append(append4);

        n.f4.accept(this);
    }

    /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
    public void visit(AllocationExpression n)   // NOT DONE <----------- FIXME // DO MAKE CLASS RECORD HERE
    {
        n.f0.accept(this);
        n.f1.accept(this);

            Struct cstruct = symbol_table.get("Global").get(cur_name);

            Vector<Struct> vs = helper.fields(cstruct, symbol_table);   // alphabetic ordered ...

            // System.out.println("alloc: " + cur_name);
            // System.out.println("here");
            // for( Struct s : vs )
            // {
            //     System.out.println(s.getName());
            // }
            // System.out.println("there");

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            //  need 4 + 4*size of vector bytes for the record
            int sz = 4 + (4*vs.size());

            String vtab = "vmt_" + cur_name;

            String tmpv = var_name + Integer.toString(var_cnt);
            var_cnt++;
            var_stk.push(tmpv);

            String null_lbl = lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            str_buf.append( printdent + tmpv + " = HeapAllocZ(" + Integer.toString(sz) + ")\n" ); // allocate record
            str_buf.append( printdent + "[" + tmpv + "] = :" + vtab + "\n" );                     // set position 0 to vtable
            str_buf.append( printdent + "if " + tmpv + " goto :" + null_lbl + "\n" );             // check null
            str_buf.append( printdent + "  " + "Error(\"null pointer\")\n" );
            str_buf.append( printdent + null_lbl + ":\n" );

        n.f2.accept(this);
        n.f3.accept(this);
    }

    /**
    * f0 -> "!"
    * f1 -> Expression()
    */
    public void visit(NotExpression n)
    {
        n.f0.accept(this);
        n.f1.accept(this);

            // str_buf.append("not expression\n");

            String printdent = "";
            for(int i = 0; i < indent_cnt; i++)
            {
                printdent += indent;
            }

            // pop
            String v1 = var_stk.pop();

            // here do the double if same for and/not
            // two if0 instructions that check if each of the operands is zero,
            // assign zero to the result and goto the end label.
            // Before the end label, one is assigned to the result.

            String tv1 = var_name + Integer.toString(var_cnt); //v1
            var_cnt++;

            String tv2 = var_name + Integer.toString(var_cnt); // 0
            var_cnt++;

            String tv3 = var_name + Integer.toString(var_cnt); // v1 < 0
            var_cnt++;

            String tv4 = var_name + Integer.toString(var_cnt); // result value of the and, set to either 0 or 1
            var_cnt++;

            String lb1 = lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            String lb2 = lbl_name + Integer.toString(lbl_cnt);
            lbl_cnt++;

            // str_buf.append(printdent + "in NOT Expression !!!!!!!!!!!"+ "\n");
            // str_buf.append(printdent + "v1: " + v1+ "\n");

            String x = tv1 + " = " + v1 + "\n";
            str_buf.append(printdent + x); // set tmp to var1

            String y = tv2 + " = " + "0" + "\n";
            str_buf.append(printdent + y); // set tmp to 0

            String z = tv3 + " = " +  "Eq(" +  tv1 + " " + tv2 + ")\n"; // if is 0 then v1 = true
            str_buf.append(printdent + z); // is v1 = 0 ?

            str_buf.append(  printdent + "if0 " + tv3 + " goto :" + lb1 + "\n" ); // if the val was 0 then goto else
            String d = tv4 + " = 1\n";
            str_buf.append("  " + printdent + d); // set tmp to 1
            str_buf.append("  " + printdent + "goto :" + lb2 + "\n" ); // set tmp to 0
            // ELSE
            str_buf.append( printdent + lb1 + ":\n"); // else label - is TRUE
            // else set result to 0
            String e = tv4 + " = 0\n";
            str_buf.append("  " + printdent + e); // set tmp to 1

            // END
            str_buf.append(printdent + lb2 + ":\n"); // else label - both were true

            if(if_param_flag == true)
            {
                if_param_arg = tv4;
            }

            // str_buf.append(printdent + "End of the NOT expression !!!!!!!!!!!!!!!\n");
    }

    /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
    public void visit(BracketExpression n)
    {
        n.f0.accept(this);
        n.f1.accept(this);
        n.f2.accept(this);
    }

}
